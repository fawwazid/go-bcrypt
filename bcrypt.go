// Package gobcrypt provides a wrapper around golang.org/x/crypto/bcrypt
// that enforces modern security recommendations for password hashing.
//
// It handles:
//   - Minimum cost enforcement (MinCost = 12).
//   - Long password support via SHA-256 pre-hashing (bypassing the 72-byte limit).
//   - Output with $2b$ prefix for consistency with modern practices.
//
// IMPORTANT: This library pre-hashes ALL passwords with SHA-256 before bcrypt.
// This means hashes generated by this library are NOT compatible with standard
// bcrypt implementations. You cannot migrate existing bcrypt hashes to this library
// without rehashing all passwords.
package gobcrypt

import (
	"errors"
	"fmt"

	"golang.org/x/crypto/bcrypt"
)

const (
	// DefaultCost is the default cost for the bcrypt algorithm.
	// It is set to 14, a reasonable default for modern hardware.
	DefaultCost = 14

	// MinCost is the minimum allowed cost.
	// Costs below this value will result in an error.
	MinCost = 12

	// MaxCost is the maximum allowed cost.
	MaxCost = 31
)

// ErrCostTooLow is returned when the provided cost is below MinCost.
var ErrCostTooLow = errors.New("gobcrypt: cost is below minimum allowed cost")

// Generate returns the bcrypt hash of the password at the given cost.
//
// If the cost is less than MinCost, it returns ErrCostTooLow.
// If the cost is greater than MaxCost, it returns an error.
//
// IMPORTANT: This function pre-hashes ALL passwords with SHA-256 before bcrypt.
// This ensures passwords of any length are processed consistently and securely,
// but all passwords are reduced to 256 bits of entropy, making the resulting hashes
// incompatible with standard bcrypt implementations.
func Generate(password []byte, cost int) ([]byte, error) {
	if cost < MinCost {
		return nil, fmt.Errorf("%w: got %d", ErrCostTooLow, cost)
	}
	if cost > MaxCost {
		return nil, fmt.Errorf("gobcrypt: cost %d exceeds maximum allowed cost %d", cost, MaxCost)
	}

	// Pre-hash the password to handle lengths > 72 bytes.
	// We base64 encode the SHA-256 hash to keep it within the printable range bcrypt expects.
	finalPassword := PreHashPassword(password)

	hash, err := bcrypt.GenerateFromPassword(finalPassword, cost)
	if err != nil {
		return nil, fmt.Errorf("gobcrypt: failed to generate hash: %w", err)
	}

	// Set $2b$ prefix on output for consistency with modern practices.
	// Note: golang.org/x/crypto/bcrypt uses $2a$ by default and is completely safe.
	// This is a cosmetic change for signaling modern implementation practices.
	hash = upgrade2aTo2b(hash)

	return hash, nil
}

// upgrade2aTo2b converts a bcrypt hash with $2a$ prefix to $2b$ prefix.
// This is a cosmetic change as both prefixes are functionally equivalent
// in Go's bcrypt implementation, but $2b$ signals modern practices.
// Always returns a new slice to avoid mutating the input and ensure consistent behavior.
func upgrade2aTo2b(hash []byte) []byte {
	result := make([]byte, len(hash))
	copy(result, hash)
	if len(hash) > 3 && hash[0] == '$' && hash[1] == '2' && hash[2] == 'a' {
		result[2] = 'b'
	}
	return result
}

// Compare compares a bcrypt hashed password with its possible plaintext equivalent.
// Returns nil on success, or an error on failure.
//
// IMPORTANT: This function only verifies passwords that were pre-hashed using
// this library's Generate function. It is NOT compatible with standard bcrypt
// hashes created by other libraries.
//
// For backward compatibility, this function attempts verification with both
// the current encoding (StdEncoding with padding) and legacy encoding
// (RawStdEncoding without padding).
func Compare(hash, password []byte) error {
	// First try with current encoding (StdEncoding with padding)
	finalPassword := PreHashPassword(password)
	err := bcrypt.CompareHashAndPassword(hash, finalPassword)
	if err == nil {
		return nil
	}

	// If that failed, try with legacy encoding (RawStdEncoding without padding)
	// for backward compatibility with older hashes
	legacyPassword := PreHashPasswordLegacy(password)
	legacyErr := bcrypt.CompareHashAndPassword(hash, legacyPassword)
	if legacyErr == nil {
		return nil
	}

	// Both encoding attempts failed; return a wrapped error with both error messages
	return fmt.Errorf("gobcrypt: password comparison failed: %w", errors.Join(err, legacyErr))
}

// Cost returns the hashing cost used to create the given hash.
func Cost(hash []byte) (int, error) {
	cost, err := bcrypt.Cost(hash)
	if err != nil {
		return 0, fmt.Errorf("gobcrypt: invalid hash: %w", err)
	}
	return cost, nil
}

// NeedsRehash checks if the hash needs to be regenerated.
// This returns true if:
//   - The hash is invalid.
//   - The cost of the hash is lower than the targetCost.
//
// This is useful for automatically upgrading legacy hashes to newer standards.
func NeedsRehash(hash []byte, targetCost int) bool {
	c, err := bcrypt.Cost(hash)
	if err != nil {
		return true
	}
	return c < targetCost
}
