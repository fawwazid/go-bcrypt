// Package gobcrypt provides a wrapper around golang.org/x/crypto/bcrypt
// that enforces modern security recommendations for password hashing.
//
// It handles:
//   - Minimum cost enforcement (MinCost = 12).
//   - Long password support via SHA-256 pre-hashing (bypassing the 72-byte limit).
//   - Output with $2b$ prefix for consistency with modern practices.
//
// IMPORTANT: This library pre-hashes ALL passwords with SHA-256 before bcrypt.
// This means hashes generated by this library are NOT compatible with standard
// bcrypt implementations. You cannot migrate existing bcrypt hashes to this library
// without rehashing all passwords.
package gobcrypt

import (
	"errors"
	"fmt"

	"golang.org/x/crypto/bcrypt"
)

const (
	// DefaultCost is the default cost for the bcrypt algorithm.
	// It is set to a work factor that takes a significant amount of time.
	// 14 is a reasonable default for modern hardware.
	DefaultCost = 14

	// MinCost is the minimum allowed cost.
	// Costs below this value will result in an error.
	MinCost = 12

	// MaxCost is the maximum allowed cost.
	MaxCost = 31
)

// ErrCostTooLow is returned when the provided cost is below MinCost.
var ErrCostTooLow = errors.New("gobcrypt: cost is below minimum allowed cost")

// Generate returns the bcrypt hash of the password at the given cost.
//
// If the cost is less than MinCost, it returns ErrCostTooLow.
// If the cost is greater than MaxCost, it returns an error.
//
// IMPORTANT: This function pre-hashes ALL passwords with SHA-256 before bcrypt.
// This ensures passwords longer than 72 bytes retain full entropy, but makes
// the resulting hashes incompatible with standard bcrypt implementations.
func Generate(password []byte, cost int) ([]byte, error) {
	if cost < MinCost {
		return nil, fmt.Errorf("%w: got %d", ErrCostTooLow, cost)
	}
	if cost > MaxCost {
		return nil, fmt.Errorf("gobcrypt: cost %d exceeds maximum allowed cost %d", cost, MaxCost)
	}

	// Pre-hash the password to handle lengths > 72 bytes.
	// We base64 encode the SHA-256 hash to keep it within the printable range bcrypt expects.
	finalPassword := preHashPassword(password)

	hash, err := bcrypt.GenerateFromPassword(finalPassword, cost)
	if err != nil {
		return nil, fmt.Errorf("gobcrypt: failed to generate hash: %w", err)
	}

	// Set $2b$ prefix on output for consistency with modern practices.
	// Note: golang.org/x/crypto/bcrypt uses $2a$ by default and is completely safe.
	// This is a cosmetic change for signaling modern implementation practices.
	hash = upgrade2aTo2b(hash)

	return hash, nil
}

// upgrade2aTo2b converts a bcrypt hash with $2a$ prefix to $2b$ prefix.
// This is a cosmetic change as both prefixes are functionally equivalent
// in Go's bcrypt implementation, but $2b$ signals modern practices.
// Returns a new slice to avoid mutating the input.
func upgrade2aTo2b(hash []byte) []byte {
	if len(hash) > 3 && hash[0] == '$' && hash[1] == '2' && hash[2] == 'a' {
		// Create a copy to avoid mutating the input
		result := make([]byte, len(hash))
		copy(result, hash)
		result[2] = 'b'
		return result
	}
	return hash
}

// Compare compares a bcrypt hashed password with its possible plaintext equivalent.
// Returns nil on success, or an error on failure.
//
// IMPORTANT: This function only verifies passwords that were pre-hashed using
// this library's Generate function. It is NOT compatible with standard bcrypt
// hashes created by other libraries.
func Compare(hash, password []byte) error {
	// Only try with pre-hashed password (for hashes generated by this library)
	finalPassword := preHashPassword(password)
	err := bcrypt.CompareHashAndPassword(hash, finalPassword)
	if err != nil {
		// If it's already the mismatch error, return as-is
		if err == bcrypt.ErrMismatchedHashAndPassword {
			return err
		}
		// Otherwise, wrap to preserve information about invalid hash
		return fmt.Errorf("gobcrypt: invalid hash or password mismatch: %w", err)
	}
	return nil
}

// Cost returns the hashing cost used to create the given hash.
func Cost(hash []byte) (int, error) {
	cost, err := bcrypt.Cost(hash)
	if err != nil {
		return 0, fmt.Errorf("gobcrypt: invalid hash: %w", err)
	}
	return cost, nil
}

// NeedsRehash checks if the hash needs to be regenerated.
// This returns true if:
//   - The hash is invalid.
//   - The cost of the hash is lower than the targetCost.
//
// This is useful for automatically upgrading legacy hashes to newer standards.
func NeedsRehash(hash []byte, targetCost int) bool {
	c, err := bcrypt.Cost(hash)
	if err != nil {
		return true
	}
	return c < targetCost
}
