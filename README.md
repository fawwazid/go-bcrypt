# Go - bcrypt

A secure wrapper for Go's bcrypt implementation.

This library provides a simplified API for hashing and verifying passwords using bcrypt, with built-in enforcement of modern security standards.

## Features

-   **Security Best Practices**:
    -   **Minimum Cost Enforcement**: Enforces a minimum cost of 12 (defaulting to 14), ensuring resistance against modern hardware attacks.
    -   **Long Password Support**: Pre-hashes all passwords with SHA-256 before bcrypt, ensuring passwords of any length retain full entropy (bcrypt natively limits passwords to 72 bytes).
-   **Modern Versioning**: Outputs hashes with the `$2b$` prefix for consistency with modern practices. Note: Go's bcrypt implementation (`$2a$`) is completely safe and was never affected by bugs that existed in some other language implementations.
-   **Backward Compatibility**: The `Compare` function can verify both hashes created by this library and standard bcrypt hashes.
-   **Simple API**: Provides easy-to-use `Generate`, `Compare`, `Cost`, and `NeedsRehash` functions.

### ⚠️ Important Compatibility Note

This library pre-hashes **all** passwords with SHA-256 before passing them to bcrypt. This means:

1. Hashes generated by this library are **not compatible** with standard bcrypt implementations (because of SHA-256 pre-hashing).
2. This library **can verify** passwords that were originally hashed with standard bcrypt (without pre-hashing); it automatically detects and verifies standard bcrypt hashes.
3. If migrating from another bcrypt library, you only need to rehash passwords if you want to use the new hashing format; existing standard bcrypt hashes can still be verified.

## Installation

```bash
go get github.com/fawwazid/go-bcrypt
```

## Usage

### Hashing a Password

```go
package main

import (
	"fmt"
	"log"

	gobcrypt "github.com/fawwazid/go-bcrypt"
)

func main() {
	password := []byte("my-super-secret-password-that-is-very-long")

	// Generate a hash with the default cost (14)
	hash, err := gobcrypt.Generate(password, gobcrypt.DefaultCost)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Printf("Hashed Password: %s\n", hash)
}
```

### Verifying a Password

```go
package main

import (
	"fmt"

	gobcrypt "github.com/fawwazid/go-bcrypt"
)

func main() {
	password := []byte("my-super-secret-password-that-is-very-long")
	hash := []byte("$2b$14$...") // Your stored hash

	err := gobcrypt.Compare(hash, password)
	if err != nil {
		fmt.Println("Invalid password")
	} else {
		fmt.Println("Password matches!")
	}
}
```

### Checking for Rehash

It is good practice to check if a password needs to be rehashed (e.g., if you have increased your security standards or the original hash used a low cost).

```go
func login(password []byte, storedHash []byte) error {
    // 1. Verify password
    if err := gobcrypt.Compare(storedHash, password); err != nil {
        // Handle invalid password
        return err
    }

    // 2. Check if we need to upgrade the hash
    if gobcrypt.NeedsRehash(storedHash, gobcrypt.DefaultCost) {
        newHash, err := gobcrypt.Generate(password, gobcrypt.DefaultCost)
        if err != nil {
            // Log the error or handle appropriately
            return err
        }
        // Save newHash to database...
        _ = newHash
    }
    return nil
}
```

## Security Details

### Why Pre-hashing?
Bcrypt has a maximum password length of 72 bytes. Passwords longer than this are truncated, which reduces security for long passphrases. This library pre-hashes **all** passwords using SHA-256 (and base64 encoding) before passing them to bcrypt. This allows for passwords of arbitrary length without losing entropy.

**Note**: Because all passwords are pre-hashed, hashes generated by this library are not compatible with standard bcrypt implementations.

### Why `$2b$`?
Standard bcrypt implementations use version prefixes to indicate the algorithm variant.
-   `$2a$`: The standard for many years. Note: a bug affecting long passwords existed in some non-Go implementations (such as PHP), but Go's bcrypt implementation was never affected.
-   `$2b$`: The modern standard. This library uses `$2b$` for compatibility with current best practices and to signal a secure, up-to-date implementation.

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.
